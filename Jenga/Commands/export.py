#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Jenga Build System - Export Command
Export to other build systems (CMake, Makefile, Premake5, Visual Studio, etc.)
"""

import sys
import os
from pathlib import Path

sys.path.insert(0, str(Path(__file__).parent.parent))

from core.loader import load_workspace
from core.api import ProjectKind
from utils.display import Display


def execute(args: list) -> int:
    """Main entry point for export command"""
    
    import argparse
    
    parser = argparse.ArgumentParser(description="Export to other build systems")
    parser.add_argument('format', choices=['cmake', 'makefile', 'premake5', 'visualstudio', 'xcode'],
                       help='Target build system')
    parser.add_argument('--output', '-o', help='Output file/directory')
    
    parsed = parser.parse_args(args)
    
    # Load workspace
    workspace = load_workspace()
    if not workspace:
        Display.error("No workspace found")
        return 1
    
    Display.section(f"Exporting to {parsed.format}")
    
    if parsed.format == 'cmake':
        return export_cmake(workspace, parsed.output)
    elif parsed.format == 'makefile':
        return export_makefile(workspace, parsed.output)
    elif parsed.format == 'premake5':
        return export_premake5(workspace, parsed.output)
    elif parsed.format == 'visualstudio':
        return export_visualstudio(workspace, parsed.output)
    elif parsed.format == 'xcode':
        return export_xcode(workspace, parsed.output)
    
    return 0


def export_cmake(workspace, output: str) -> int:
    """Export to CMakeLists.txt"""
    
    output_file = Path(output or "CMakeLists.txt")
    
    Display.info(f"Generating: {output_file}")
    
    content = []
    
    # CMake header
    content.append("# Generated by Jenga Build System")
    content.append("# CMakeLists.txt")
    content.append("")
    content.append("cmake_minimum_required(VERSION 3.15)")
    content.append(f"project({workspace.name})")
    content.append("")
    content.append("set(CMAKE_CXX_STANDARD 17)")
    content.append("set(CMAKE_CXX_STANDARD_REQUIRED ON)")
    content.append("")
    
    # Projects
    for proj_name, project in workspace.projects.items():
        content.append(f"# Project: {proj_name}")
        
        # Determine target type
        if project.kind == ProjectKind.CONSOLE_APP or project.kind == ProjectKind.WINDOWED_APP:
            content.append(f"add_executable({proj_name}")
        elif project.kind == ProjectKind.STATIC_LIB:
            content.append(f"add_library({proj_name} STATIC")
        elif project.kind == ProjectKind.SHARED_LIB:
            content.append(f"add_library({proj_name} SHARED")
        else:
            content.append(f"add_executable({proj_name}")
        
        # Source files
        if project.files:
            for file_pattern in project.files:
                # Convert pattern to CMake GLOB
                if "**" in file_pattern:
                    file_pattern = file_pattern.replace("**", "*")
                content.append(f"    {file_pattern}")
        
        content.append(")")
        content.append("")
        
        # Include directories
        if project.includedirs:
            includes = ' '.join(f'"{inc}"' for inc in project.includedirs)
            content.append(f"target_include_directories({proj_name} PRIVATE {includes})")
        
        # Defines
        if project.defines:
            defines = ' '.join(project.defines)
            content.append(f"target_compile_definitions({proj_name} PRIVATE {defines})")
        
        # Link libraries
        if project.links:
            libs = ' '.join(project.links)
            content.append(f"target_link_libraries({proj_name} {libs})")
        
        # Dependencies (other projects)
        if project.dependencies:
            deps = ' '.join(project.dependencies)
            content.append(f"target_link_libraries({proj_name} {deps})")
        
        content.append("")
    
    # Write file
    output_file.write_text('\n'.join(content))
    
    Display.success(f"✓ Generated: {output_file}")
    Display.info("\nBuild with:")
    print("  mkdir build && cd build")
    print("  cmake ..")
    print("  make")
    
    return 0


def export_makefile(workspace, output: str) -> int:
    """Export to Makefile"""
    
    output_file = Path(output or "Makefile")
    
    Display.info(f"Generating: {output_file}")
    
    content = []
    
    # Makefile header
    content.append("# Generated by Jenga Build System")
    content.append("# Makefile")
    content.append("")
    content.append("CXX = g++")
    content.append("CXXFLAGS = -std=c++17 -Wall")
    content.append("")
    
    # Targets
    all_targets = []
    
    for proj_name, project in workspace.projects.items():
        all_targets.append(proj_name)
        
        # Determine output
        if project.kind == ProjectKind.STATIC_LIB:
            output_name = f"lib{proj_name}.a"
        elif project.kind == ProjectKind.SHARED_LIB:
            output_name = f"lib{proj_name}.so"
        else:
            output_name = proj_name
        
        content.append(f"# {proj_name}")
        
        # Variables
        src_var = f"{proj_name.upper()}_SRC"
        obj_var = f"{proj_name.upper()}_OBJ"
        
        # Source files
        if project.files:
            sources = []
            for pattern in project.files:
                # Simple pattern expansion
                sources.append(pattern.replace("**", "*"))
            content.append(f"{src_var} = {' '.join(sources)}")
        
        # Object files
        content.append(f"{obj_var} = $({src_var}:.cpp=.o)")
        content.append("")
        
        # Includes
        includes = ""
        if project.includedirs:
            includes = ' '.join(f"-I{inc}" for inc in project.includedirs)
        
        # Defines
        defines = ""
        if project.defines:
            defines = ' '.join(f"-D{d}" for d in project.defines)
        
        # Links
        links = ""
        if project.links:
            links = ' '.join(f"-l{lib}" for lib in project.links)
        
        # Dependencies
        deps = ""
        if project.dependencies:
            deps = ' '.join(f"-l{dep}" for dep in project.dependencies)
        
        # Target rule
        content.append(f"{proj_name}: $({obj_var})")
        
        if project.kind == ProjectKind.STATIC_LIB:
            content.append(f"\tar rcs {output_name} $({obj_var})")
        elif project.kind == ProjectKind.SHARED_LIB:
            content.append(f"\t$(CXX) -shared -o {output_name} $({obj_var}) {links} {deps}")
        else:
            content.append(f"\t$(CXX) -o {output_name} $({obj_var}) {links} {deps}")
        
        content.append("")
        
        # Compilation rule
        content.append(f"%.o: %.cpp")
        content.append(f"\t$(CXX) $(CXXFLAGS) {includes} {defines} -c $< -o $@")
        content.append("")
    
    # All target
    content.insert(5, f"all: {' '.join(all_targets)}")
    content.insert(6, "")
    
    # Clean target
    content.append("clean:")
    content.append("\trm -f **/*.o")
    for proj_name in all_targets:
        content.append(f"\trm -f {proj_name}")
    content.append("")
    
    content.append(".PHONY: all clean")
    
    # Write file
    output_file.write_text('\n'.join(content))
    
    Display.success(f"✓ Generated: {output_file}")
    Display.info("\nBuild with:")
    print("  make")
    
    return 0


def export_premake5(workspace, output: str) -> int:
    """Export to premake5.lua"""
    
    output_file = Path(output or "premake5.lua")
    
    Display.info(f"Generating: {output_file}")
    
    content = []
    
    # Premake header
    content.append("-- Generated by Jenga Build System")
    content.append("-- premake5.lua")
    content.append("")
    content.append(f'workspace "{workspace.name}"')
    content.append('    configurations { "Debug", "Release" }')
    content.append('    platforms { "x64" }')
    content.append("")
    
    # Projects
    for proj_name, project in workspace.projects.items():
        content.append(f'project "{proj_name}"')
        
        # Kind
        if project.kind == ProjectKind.CONSOLE_APP:
            content.append('    kind "ConsoleApp"')
        elif project.kind == ProjectKind.WINDOWED_APP:
            content.append('    kind "WindowedApp"')
        elif project.kind == ProjectKind.STATIC_LIB:
            content.append('    kind "StaticLib"')
        elif project.kind == ProjectKind.SHARED_LIB:
            content.append('    kind "SharedLib"')
        
        content.append('    language "C++"')
        content.append('    cppdialect "C++17"')
        content.append("")
        
        # Files
        if project.files:
            content.append('    files {')
            for file_pattern in project.files:
                content.append(f'        "{file_pattern}",')
            content.append('    }')
            content.append("")
        
        # Includes
        if project.includedirs:
            content.append('    includedirs {')
            for inc in project.includedirs:
                content.append(f'        "{inc}",')
            content.append('    }')
            content.append("")
        
        # Defines
        if project.defines:
            content.append('    defines {')
            for define in project.defines:
                content.append(f'        "{define}",')
            content.append('    }')
            content.append("")
        
        # Links
        if project.links:
            content.append('    links {')
            for link in project.links:
                content.append(f'        "{link}",')
            content.append('    }')
            content.append("")
        
        # Dependencies
        if project.dependencies:
            content.append('    links {')
            for dep in project.dependencies:
                content.append(f'        "{dep}",')
            content.append('    }')
            content.append("")
        
        # Configurations
        content.append('    filter "configurations:Debug"')
        content.append('        defines { "DEBUG" }')
        content.append('        symbols "On"')
        content.append("")
        
        content.append('    filter "configurations:Release"')
        content.append('        defines { "NDEBUG" }')
        content.append('        optimize "On"')
        content.append("")
    
    # Write file
    output_file.write_text('\n'.join(content))
    
    Display.success(f"✓ Generated: {output_file}")
    Display.info("\nGenerate with:")
    print("  premake5 vs2022")
    print("  premake5 gmake2")
    
    return 0


def export_visualstudio(workspace, output: str) -> int:
    """Export to Visual Studio solution"""
    
    Display.step("Generating Visual Studio solution...")
    
    # Use premake5 as intermediate
    premake_file = Path("premake5.lua")
    export_premake5(workspace, str(premake_file))
    
    # Generate VS solution
    try:
        import subprocess
        result = subprocess.run(['premake5', 'vs2022'], capture_output=True, text=True)
        
        if result.returncode == 0:
            Display.success("✓ Visual Studio solution generated")
            Display.info(f"Open: {workspace.name}.sln")
            return 0
        else:
            Display.error("Failed to generate VS solution")
            Display.info("Install premake5: https://premake.github.io/")
            return 1
    
    except FileNotFoundError:
        Display.error("premake5 not found")
        Display.info("Install premake5: https://premake.github.io/")
        Display.info(f"Or use generated: {premake_file}")
        return 1


def export_xcode(workspace, output: str) -> int:
    """Export to Xcode project"""
    
    Display.step("Generating Xcode project...")
    
    # Use CMake as intermediate
    cmake_file = Path("CMakeLists.txt")
    export_cmake(workspace, str(cmake_file))
    
    # Generate Xcode project
    try:
        import subprocess
        
        build_dir = Path("xcode_build")
        build_dir.mkdir(exist_ok=True)
        
        result = subprocess.run(
            ['cmake', '-G', 'Xcode', '..'],
            cwd=build_dir,
            capture_output=True,
            text=True
        )
        
        if result.returncode == 0:
            Display.success("✓ Xcode project generated")
            Display.info(f"Open: xcode_build/{workspace.name}.xcodeproj")
            return 0
        else:
            Display.error("Failed to generate Xcode project")
            return 1
    
    except FileNotFoundError:
        Display.error("cmake not found")
        Display.info(f"Or use generated: {cmake_file}")
        return 1


if __name__ == "__main__":
    sys.exit(execute(sys.argv[1:]))
