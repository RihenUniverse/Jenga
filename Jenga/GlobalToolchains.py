# Auto-generated by 'jenga install toolchain'.
# Optional import helper for workspace scripts.
import os
import platform as platform_module
import shutil
from pathlib import Path
from typing import Dict, List, Optional, Union

from Jenga.Core.Api import *

# ----------------------------------------------------------------------
# Platform detection and helpers (PascalCase methods)
# ----------------------------------------------------------------------

class Platform:
    """Encapsulates host platform information and common operations."""

    system = platform_module.system()          # 'Windows', 'Linux', 'Darwin'
    machine = platform_module.machine().lower() # 'x86_64', 'arm64', 'amd64', etc.

    @classmethod
    def IsWindows(cls) -> bool:
        return cls.system == "Windows"

    @classmethod
    def IsLinux(cls) -> bool:
        return cls.system == "Linux"

    @classmethod
    def IsMacOS(cls) -> bool:
        return cls.system == "Darwin"

    @classmethod
    def Is64Bit(cls) -> bool:
        return cls.machine.endswith(('64', 'amd64', 'x86_64'))

    @classmethod
    def ExeSuffix(cls) -> str:
        return ".exe" if cls.IsWindows() else ""

    @classmethod
    def ScriptSuffix(cls) -> str:
        return ".bat" if cls.IsWindows() else ""

    @classmethod
    def NdkHostTag(cls) -> str:
        """Return the NDK prebuilt host tag for the current platform."""
        if cls.IsWindows():
            return "windows-x86_64"
        elif cls.IsLinux():
            return "linux-x86_64"
        elif cls.IsMacOS():
            return "darwin-arm64" if cls.machine == "arm64" else "darwin-x86_64"
        else:
            return "windows-x86_64"  # fallback

    @classmethod
    def DefaultShell(cls) -> str:
        """Return the default shell for the platform."""
        if cls.IsWindows():
            return "cmd.exe"
        else:
            return "/bin/sh"

    @classmethod
    def FindExecutable(cls, names: Union[str, List[str]], extra_paths: Optional[List[Path]] = None) -> Optional[str]:
        """
        Search for an executable among possible names.
        If extra_paths are given, they are prepended to the system PATH.
        Returns the absolute path if found, else None.
        """
        if isinstance(names, str):
            names = [names]

        # Build a custom PATH string
        orig_path = os.environ.get("PATH", "")
        extra_path_str = ""
        if extra_paths:
            extra_dirs = [str(p) for p in extra_paths if p.exists()]
            extra_path_str = os.pathsep.join(extra_dirs) + os.pathsep

        search_path = extra_path_str + orig_path

        for name in names:
            # On Windows, if the name doesn't have an extension, shutil.which will try PATHEXT
            exe = shutil.which(name, path=search_path)
            if exe:
                return exe
        return None

    @classmethod
    def ResolveTool(cls,
                     base_dir: Optional[Path],
                     tool_names: Union[str, List[str]],
                     subdir: str = "bin",
                     required: bool = True) -> Optional[str]:
        """
        Try to locate a tool:
          1. If base_dir is given, look in base_dir / subdir.
          2. If not found, fallback to searching in PATH.
          3. If still not found and required is True, raise an error.
        Returns the absolute path as a string (or None if not required and not found).
        """
        extra_paths = [base_dir / subdir] if base_dir and (base_dir / subdir).exists() else []
        exe_path = cls.FindExecutable(tool_names, extra_paths=extra_paths if extra_paths else None)

        if not exe_path and required:
            names_str = ", ".join(tool_names) if isinstance(tool_names, list) else tool_names
            raise EnvironmentError(
                f"Could not find '{names_str}'. "
                f"Please ensure it is installed and either set the appropriate "
                f"environment variable or provide the correct root path."
            )
        return exe_path

    @classmethod
    def GetEnvPath(cls, *env_vars: str) -> Optional[str]:
        """Return the first non-empty environment variable value."""
        for var in env_vars:
            val = os.environ.get(var)
            if val:
                return val
        return None

# ----------------------------------------------------------------------
# Individual toolchain registration functions (configurable)
# ----------------------------------------------------------------------

def ToolchainAndroidNDK(ndk_root: Optional[str] = None) -> None:
    """
    Register android-ndk toolchain.
    The NDK root can be specified via the `ndk_root` argument,
    or the environment variables ANDROID_NDK_ROOT, ANDROID_NDK_HOME, ANDROID_HOME.
    """
    if ndk_root is None:
        ndk_root = Platform.GetEnvPath("ANDROID_NDK_ROOT", "ANDROID_NDK_HOME", "ANDROID_HOME")
        if ndk_root is None:
            raise EnvironmentError(
                "ANDROID_NDK_ROOT must be set or passed as argument to ToolchainAndroidNDK()"
            )

    ndk_root = Path(ndk_root)
    # If ANDROID_HOME was used, NDK is typically under $ANDROID_HOME/ndk/<version>
    if "ANDROID_HOME" in os.environ and ndk_root == Path(os.environ["ANDROID_HOME"]):
        # Try to find the latest NDK version
        ndk_dir = ndk_root / "ndk"
        if ndk_dir.exists():
            versions = [d for d in ndk_dir.iterdir() if d.is_dir()]
            if versions:
                # Use the latest version (lexicographic sort works for versions like 23.1.7779620)
                latest = sorted(versions)[-1]
                ndk_root = latest

    host_tag = Platform.NdkHostTag()
    toolchain_bin = ndk_root / "toolchains" / "llvm" / "prebuilt" / host_tag / "bin"

    # Required tools
    c_compiler_path = Platform.ResolveTool(toolchain_bin.parent, ["clang", "clang.exe"], subdir="bin")
    cpp_compiler_path = Platform.ResolveTool(toolchain_bin.parent, ["clang++", "clang++.exe"], subdir="bin")
    linker_path = Platform.ResolveTool(toolchain_bin.parent, ["ld", "ld.exe"], subdir="bin")
    archiver_path = Platform.ResolveTool(toolchain_bin.parent, ["llvm-ar", "llvm-ar.exe"], subdir="bin")

    with toolchain("android-ndk", "android-ndk"):
        settarget("Android", "arm64", "android")
        ccompiler(c_compiler_path)
        cppcompiler(cpp_compiler_path)
        linker(linker_path)
        archiver(archiver_path)


def ToolchainClangCl(msvc_base: Optional[str] = None) -> None:
    """
    Register clang-cl toolchain (Windows, MSVC style).
    Only available on Windows. The MSVC base directory can be specified via `msvc_base`
    or the environment variable MSVC_BASE. If not provided, we try to find clang-cl
    in PATH and assume its location.
    """
    if not Platform.IsWindows():
        print("Warning: clang-cl toolchain is only supported on Windows. Skipping.")
        return

    if msvc_base is None:
        msvc_base = Platform.GetEnvPath("MSVC_BASE")
        if msvc_base is None:
            # Try to locate clang-cl in PATH
            clang_cl_path = Platform.FindExecutable("clang-cl")
            if clang_cl_path:
                # Assume clang-cl is in a bin/ directory; the base could be two levels up
                msvc_base = str(Path(clang_cl_path).parent.parent)
            else:
                raise EnvironmentError(
                    "MSVC_BASE not set and clang-cl not found in PATH. "
                    "Please provide msvc_base argument or set MSVC_BASE."
                )

    base_dir = Path(msvc_base)
    bin_dir = base_dir / "bin"

    c_compiler_path = Platform.ResolveTool(base_dir, ["clang-cl", "clang-cl.exe"], subdir="bin")
    cpp_compiler = c_compiler  # same executable
    linker = c_compiler
    archiver_path = Platform.ResolveTool(base_dir, ["ar", "ar.exe", "llvm-ar", "llvm-ar.exe"], subdir="bin")

    with toolchain("clang-cl", "clang"):
        settarget("Windows", "x86_64", "msvc")
        ccompiler(c_compiler_path)
        cppcompiler(cpp_compiler_path)
        linker(linker_path)
        archiver(archiver_path)


def ToolchainClangNative(clang_base: Optional[str] = None) -> None:
    """
    Register a native Clang toolchain that targets the current host platform.
    The base directory (containing bin/) can be given via `clang_base`
    or the environment variable CLANG_BASE.
    """
    if clang_base is None:
        clang_base = Platform.GetEnvPath("CLANG_BASE")
        if clang_base is None:
            # Try to locate clang in PATH
            clang_path = Platform.FindExecutable("clang")
            if clang_path:
                clang_base = str(Path(clang_path).parent.parent)
            else:
                raise EnvironmentError(
                    "CLANG_BASE not set and clang not found in PATH. "
                    "Please provide clang_base argument or set CLANG_BASE."
                )

    base_dir = Path(clang_base)
    bin_dir = base_dir / "bin"

    c_compiler_path = Platform.ResolveTool(base_dir, ["clang", "clang.exe"], subdir="bin")
    cpp_compiler_path = Platform.ResolveTool(base_dir, ["clang++", "clang++.exe"], subdir="bin")
    linker = cpp_compiler  # usually clang++ as linker driver
    archiver_path = Platform.ResolveTool(base_dir, ["ar", "ar.exe", "llvm-ar", "llvm-ar.exe"], subdir="bin")

    # Determine target triple based on host platform
    if Platform.IsWindows():
        target_os = "Windows"
        target_arch = "x86_64"
        target_env = "mingw"  # assuming MinGW style, but could be msvc if using clang-cl
        triple = "x86_64-pc-windows-gnu"
    elif Platform.IsLinux():
        target_os = "Linux"
        target_arch = "x86_64"
        target_env = "gnu"
        triple = "x86_64-unknown-linux-gnu"
    elif Platform.IsMacOS():
        target_os = "Darwin"
        target_arch = "arm64" if Platform.machine == "arm64" else "x86_64"
        target_env = "macosx"
        triple = f"{target_arch}-apple-darwin"
    else:
        target_os = "Unknown"
        target_arch = "x86_64"
        target_env = "unknown"
        triple = "x86_64-unknown-unknown"

    with toolchain("clang-native", "clang"):
        settarget(target_os, target_arch, target_env)
        targettriple(triple)
        ccompiler(c_compiler_path)
        cppcompiler(cpp_compiler_path)
        linker(linker_path)
        archiver(archiver_path)
        # Add target flags if needed (Clang usually defaults to host, but we can be explicit)
        cflags([f"--target={triple}"])
        cxxflags([f"--target={triple}"])
        ldflags([f"--target={triple}"])


def ToolchainClangCrossLinux(clang_base: Optional[str] = None) -> None:
    """
    Register clang cross‑compiler for Linux (x86_64).
    This is useful when the host is not Linux (e.g., Windows or macOS).
    The base directory (containing bin/) can be given via `clang_base`
    or the environment variable CLANG_BASE.
    """
    if clang_base is None:
        clang_base = Platform.GetEnvPath("CLANG_BASE")
        if clang_base is None:
            clang_path = Platform.FindExecutable("clang")
            if clang_path:
                clang_base = str(Path(clang_path).parent.parent)
            else:
                raise EnvironmentError(
                    "CLANG_BASE not set and clang not found in PATH. "
                    "Please provide clang_base argument or set CLANG_BASE."
                )

    base_dir = Path(clang_base)
    bin_dir = base_dir / "bin"

    c_compiler_path = Platform.ResolveTool(base_dir, ["clang", "clang.exe"], subdir="bin")
    cpp_compiler_path = Platform.ResolveTool(base_dir, ["clang++", "clang++.exe"], subdir="bin")
    linker = cpp_compiler
    archiver_path = Platform.ResolveTool(base_dir, ["ar", "ar.exe", "llvm-ar", "llvm-ar.exe"], subdir="bin")

    with toolchain("clang-cross-linux", "clang"):
        settarget("Linux", "x86_64", "gnu")
        targettriple("x86_64-unknown-linux-gnu")
        ccompiler(c_compiler_path)
        cppcompiler(cpp_compiler_path)
        linker(linker_path)
        archiver(archiver_path)
        cflags(["--target=x86_64-unknown-linux-gnu"])
        cxxflags(["--target=x86_64-unknown-linux-gnu"])
        ldflags(["--target=x86_64-unknown-linux-gnu"])


def ToolchainClangMinGW(mingw_root: Optional[str] = None) -> None:
    """
    Register clang-mingw toolchain (Windows, MinGW environment).
    The MinGW root (e.g. C:/msys64/ucrt64) can be given via `mingw_root`
    or the environment variable MINGW_ROOT.
    """
    if not Platform.IsWindows():
        print("Warning: MinGW toolchains are primarily for Windows. On Unix, consider using the native Clang toolchain.")
        # On Linux/macOS, we might still have mingw-w64 for cross-compilation, but let's keep it simple.

    if mingw_root is None:
        mingw_root = Platform.GetEnvPath("MINGW_ROOT")
        if mingw_root is None:
            # Try to locate clang in PATH and guess root
            clang_path = Platform.FindExecutable("clang")
            if clang_path:
                mingw_root = str(Path(clang_path).parent.parent)
            else:
                raise EnvironmentError(
                    "MINGW_ROOT not set and clang not found in PATH. "
                    "Please provide mingw_root argument or set MINGW_ROOT."
                )

    base_dir = Path(mingw_root)
    bin_dir = base_dir / "bin"

    c_compiler_path = Platform.ResolveTool(base_dir, ["clang", "clang.exe"], subdir="bin")
    cpp_compiler_path = Platform.ResolveTool(base_dir, ["clang++", "clang++.exe"], subdir="bin")
    linker_path = Platform.ResolveTool(base_dir, ["ld", "ld.exe"], subdir="bin")
    archiver_path = Platform.ResolveTool(base_dir, ["ar", "ar.exe", "llvm-ar", "llvm-ar.exe"], subdir="bin")

    with toolchain("clang-mingw", "clang"):
        settarget("Windows", "x86_64", "mingw")
        ccompiler(c_compiler_path)
        cppcompiler(cpp_compiler_path)
        linker(linker_path)
        archiver(archiver_path)


def ToolchainEmscripten(emsdk_root: Optional[str] = None) -> None:
    """
    Register emscripten toolchain.
    The EMSDK root can be given via `emsdk_root` or the environment variable EMSDK.
    """
    if emsdk_root is None:
        emsdk_root = Platform.GetEnvPath("EMSDK")
        if emsdk_root is None:
            # Try to locate emcc in PATH
            emcc_path = Platform.FindExecutable(["emcc", "emcc.bat"])
            if emcc_path:
                # emcc is typically in emsdk/upstream/emscripten/
                emsdk_root = str(Path(emcc_path).parent.parent.parent)
            else:
                raise EnvironmentError(
                    "EMSDK not set and emcc not found in PATH. "
                    "Please provide emsdk_root argument or set EMSDK."
                )

    base_dir = Path(emsdk_root)
    # emscripten executables are in upstream/emscripten/
    emcc_dir = base_dir / "upstream" / "emscripten"

    c_compiler_path = Platform.ResolveTool(emcc_dir, ["emcc", "emcc.bat"], subdir=".")
    cpp_compiler_path = Platform.ResolveTool(emcc_dir, ["em++", "em++.bat"], subdir=".")
    archiver_path = Platform.ResolveTool(emcc_dir, ["emar", "emar.bat"], subdir=".")

    with toolchain("emscripten", "emscripten"):
        settarget("Web", "wasm32")
        ccompiler(c_compiler_path)
        cppcompiler(cpp_compiler_path)
        archiver(archiver_path)


def ToolchainMinGW(mingw_root: Optional[str] = None) -> None:
    """
    Register mingw (GCC) toolchain.
    The MinGW root can be given via `mingw_root` or the environment variable MINGW_ROOT.
    """
    if mingw_root is None:
        mingw_root = Platform.GetEnvPath("MINGW_ROOT")
        if mingw_root is None:
            # Try to locate x86_64-w64-mingw32-gcc in PATH
            gcc_path = Platform.FindExecutable("x86_64-w64-mingw32-gcc")
            if gcc_path:
                mingw_root = str(Path(gcc_path).parent.parent)
            else:
                raise EnvironmentError(
                    "MINGW_ROOT not set and x86_64-w64-mingw32-gcc not found in PATH. "
                    "Please provide mingw_root argument or set MINGW_ROOT."
                )

    base_dir = Path(mingw_root)
    bin_dir = base_dir / "bin"

    c_compiler_path = Platform.ResolveTool(base_dir, ["x86_64-w64-mingw32-gcc", "x86_64-w64-mingw32-gcc.exe"], subdir="bin")
    cpp_compiler_path = Platform.ResolveTool(base_dir, ["x86_64-w64-mingw32-g++", "x86_64-w64-mingw32-g++.exe"], subdir="bin")
    linker_path = Platform.ResolveTool(base_dir, ["ld", "ld.exe"], subdir="bin")
    archiver_path = Platform.ResolveTool(base_dir, ["ar", "ar.exe"], subdir="bin")

    with toolchain("mingw", "gcc"):
        settarget("Windows", "x86_64", "mingw")
        ccompiler(c_compiler_path)
        cppcompiler(cpp_compiler_path)
        linker(linker_path)
        archiver(archiver_path)


def ToolchainZigLinuxX64(zig_root: Optional[str] = None) -> None:
    """
    Register zig-linux-x64 toolchain (cross‑compile to Linux using Zig).
    The Zig installation root can be given via `zig_root` or the environment variable ZIG_ROOT.
    The root should contain the zig executable and a 'wrappers' directory with zig-cc, zig-c++ scripts.
    """
    if zig_root is None:
        zig_root = Platform.GetEnvPath("ZIG_ROOT")
        if zig_root is None:
            # Try to locate zig in PATH
            zig_path = Platform.FindExecutable("zig")
            if zig_path:
                zig_root = str(Path(zig_path).parent)
            else:
                raise EnvironmentError(
                    "ZIG_ROOT not set and zig not found in PATH. "
                    "Please provide zig_root argument or set ZIG_ROOT."
                )

    base_dir = Path(zig_root)
    zig_exe = Platform.ResolveTool(base_dir, ["zig", "zig.exe"], subdir=".")
    wrappers_dir = base_dir / "wrappers"

    # The wrappers might be in a separate location; if not found, fallback to the base dir.
    cc_wrapper = Platform.ResolveTool(wrappers_dir, ["zig-cc", f"zig-cc{Platform.ScriptSuffix()}"], subdir=".", required=False)
    if not cc_wrapper:
        cc_wrapper = Platform.ResolveTool(base_dir, ["zig-cc", f"zig-cc{Platform.ScriptSuffix()}"], subdir=".", required=False)
    if not cc_wrapper:
        # If not found, we'll use zig with arguments directly (but the original script used wrappers)
        # We'll raise an error for now.
        raise EnvironmentError(
            "Could not find zig-cc wrapper. Please ensure it exists in 'wrappers' subdirectory "
            "or provide the correct ZIG_ROOT."
        )

    cpp_wrapper = Platform.ResolveTool(wrappers_dir, ["zig-c++", f"zig-c++{Platform.ScriptSuffix()}"], subdir=".", required=False)
    if not cpp_wrapper:
        cpp_wrapper = Platform.ResolveTool(base_dir, ["zig-c++", f"zig-c++{Platform.ScriptSuffix()}"], subdir=".", required=False)
    if not cpp_wrapper:
        cpp_wrapper = cc_wrapper  # fallback

    with toolchain("zig-linux-x64", "clang"):
        settarget("Linux", "x86_64", "gnu")
        targettriple("x86_64-linux-gnu")
        ccompiler(cc_wrapper)
        cppcompiler(cpp_wrapper)
        linker(cpp_wrapper)  # same as c++ wrapper
        archiver(zig_exe)    # zig can act as archiver
        cflags(["-target", "x86_64-linux-gnu"])
        cxxflags(["-target", "x86_64-linux-gnu", "-std=c++17"])
        ldflags(["-target", "x86_64-linux-gnu"])
        arflags(["ar"])


# ----------------------------------------------------------------------
# Main registration function
# ----------------------------------------------------------------------

def RegisterJengaGlobalToolchains(config: Optional[Dict[str, str]] = None) -> None:
    """
    Register all toolchains. An optional configuration dictionary can be passed
    to override default paths. Keys correspond to the parameter names of each
    toolchain function, e.g.:
        config = {
            "ndk_root": "/path/to/ndk",
            "mingw_root": "C:/msys64/ucrt64",
            "emsdk_root": "/opt/emsdk",
            "zig_root": "/usr/local/zig",
            "clang_base": "/usr/lib/llvm",   # for native/cross clang
            "msvc_base": "C:/Program Files/Microsoft Visual Studio/2022/Community/VC/Tools/MSVC/14.34.31933",
        }
    If a key is not provided, the toolchain will rely on environment variables
    or PATH detection.
    """
    config = config or {}

    # Platform‑specific toolchains
    ToolchainAndroidNDK(ndk_root=config.get("ndk_root"))
    ToolchainEmscripten(emsdk_root=config.get("emsdk_root"))
    ToolchainZigLinuxX64(zig_root=config.get("zig_root"))

    # Clang native (always register, but target depends on host)
    ToolchainClangNative(clang_base=config.get("clang_base"))

    # Windows‑specific toolchains
    if Platform.IsWindows():
        ToolchainClangCl(msvc_base=config.get("msvc_base"))
        ToolchainClangMinGW(mingw_root=config.get("mingw_root"))
        ToolchainMinGW(mingw_root=config.get("mingw_root"))

    # Cross toolchains (useful on any host)
    ToolchainClangCrossLinux(clang_base=config.get("clang_base"))


# # example_usage.
# import os
# from pathlib import Path

# # Import du fichier contenant vos toolchains (par exemple jenga_toolchains.py)
# from jenga_toolchains import (
#     RegisterJengaGlobalToolchains,
#     ToolchainAndroidNDK,
#     ToolchainClangNative,
#     ToolchainEmscripten,
#     ToolchainMinGW,
#     Platform  # optionnel, pour vérifier la plateforme
# )

# # ----------------------------------------------------------------------
# # Exemple 1 : Utilisation simple avec variables d'environnement
# # ----------------------------------------------------------------------
# # Définissez les variables d'environnement selon votre système.
# if Platform.IsWindows():
#     os.environ["ANDROID_NDK_ROOT"] = "C:/Users/me/AppData/Local/Android/Sdk/ndk/25.2.9519653"
#     os.environ["MINGW_ROOT"] = "C:/msys64/ucrt64"
#     os.environ["EMSDK"] = "C:/emsdk-3.1.45"
#     os.environ["CLANG_BASE"] = "C:/Program Files/LLVM"  # installation standard
# elif Platform.IsLinux():
#     os.environ["ANDROID_NDK_ROOT"] = "/home/user/Android/Sdk/ndk/25.2.9519653"
#     os.environ["MINGW_ROOT"] = "/usr/x86_64-w64-mingw32"  # pour cross-compilation
#     os.environ["EMSDK"] = "/home/user/emsdk"
#     os.environ["CLANG_BASE"] = "/usr/lib/llvm-15"
# elif Platform.IsMacOS():
#     os.environ["ANDROID_NDK_ROOT"] = "/Users/user/Library/Android/sdk/ndk/25.2.9519653"
#     os.environ["EMSDK"] = "/opt/emsdk"
#     os.environ["CLANG_BASE"] = "/opt/homebrew/opt/llvm"  # via Homebrew

# # Appel sans argument : les toolchains utilisent les variables d'environnement
# print("1. Enregistrement via variables d'environnement...")
# RegisterJengaGlobalToolchains()
# print("   Terminé.\n")

# # ----------------------------------------------------------------------
# # Exemple 2 : Utilisation avec un dictionnaire de configuration
# # ----------------------------------------------------------------------
# # Pratique pour un projet spécifique sans modifier l'environnement global.
# config = {
#     "ndk_root": "/opt/android-ndk-r23c",
#     "mingw_root": "/usr/x86_64-w64-mingw32",
#     "emsdk_root": "/opt/emsdk-3.1.45",
#     "clang_base": "/usr/local/opt/llvm",      # macOS (Homebrew)
#     "msvc_base": "C:/Program Files/Microsoft Visual Studio/2022/Community/VC/Tools/MSVC/14.34.31933",  # Windows
#     "zig_root": "/home/user/zig/zig-0.11.0"
# }

# print("2. Enregistrement via dictionnaire de configuration...")
# RegisterJengaGlobalToolchains(config)
# print("   Terminé.\n")

# # ----------------------------------------------------------------------
# # Exemple 3 : Appel individuel de certaines toolchains
# # ----------------------------------------------------------------------
# # Si vous ne voulez enregistrer qu'une toolchain particulière.

# print("3. Enregistrement individuel :")
# ToolchainAndroidNDK(ndk_root="/home/user/android-ndk-r21e")
# print("   - Android NDK enregistrée.")
# ToolchainClangNative(clang_base="/opt/llvm-14")
# print("   - Clang native enregistrée.")
# ToolchainEmscripten(emsdk_root="/home/user/emsdk-2.0.0")
# print("   - Emscripten enregistrée.\n")

# # ----------------------------------------------------------------------
# # Exemple 4 : Détection automatique via PATH (si les outils sont installés)
# # ----------------------------------------------------------------------
# # Si 'clang' est dans le PATH, ToolchainClangNative le trouvera.

# print("4. Enregistrement avec détection PATH (si disponible) :")
# try:
#     ToolchainClangNative()  # pas d'argument, cherche dans PATH
#     print("   - Clang native détectée via PATH.")
# except EnvironmentError as e:
#     print("   - Échec de la détection automatique :", e)

# # ----------------------------------------------------------------------
# # Exemple 5 : Combinaison de plusieurs approches
# # ----------------------------------------------------------------------
# # On peut aussi définir partiellement les variables et surcharger avec config.

# print("\n5. Combinaison : variables d'env + surcharge config")
# os.environ["ANDROID_NDK_ROOT"] = "/fallback/ndk"  # sera ignoré si config l'emporte
# mixed_config = {
#     "ndk_root": "/override/ndk",   # prioritaire
#     "clang_base": "/my/clang"
# }
# RegisterJengaGlobalToolchains(mixed_config)
# print("   Terminé.")