#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Nken Build System - Unity Build Generator
Combine tous les fichiers en un seul pour une compilation ultra-rapide
"""

from pathlib import Path
from typing import List


class UnityBuildGenerator:
    """
    Unity Build: Combine N fichiers .cpp en un seul .cpp
    
    Exemple:
        file1.cpp: 100 lignes
        file2.cpp: 100 lignes
        file3.cpp: 100 lignes
    
    Au lieu de compiler 3 fichiers séparément (3 x 1.2s = 3.6s),
    on crée unity.cpp qui fait:
        #include "file1.cpp"
        #include "file2.cpp"
        #include "file3.cpp"
    
    Et on compile unity.cpp une seule fois (0.4s)
    
    Gain: 9x plus rapide!
    
    Limitations:
    - Les symboles static/anonymous peuvent conflictuer
    - Les #pragma once ne fonctionnent pas entre fichiers
    - Utile seulement pour petits/moyens projets (<100 fichiers)
    """
    
    def __init__(self, workspace_location: str):
        self.workspace_location = workspace_location
    
    def should_use_unity_build(self, file_count: int) -> bool:
        """
        Unity build recommandé pour:
        - Petits projets: 5-50 fichiers
        - Fichiers sans conflits de symboles
        
        Pas recommandé pour:
        - >100 fichiers (unity file trop gros)
        - Fichiers avec beaucoup de static/anonymous
        """
        return 5 <= file_count <= 50
    
    def generate_unity_files(self, source_files: List[str], 
                            output_dir: Path,
                            max_files_per_unity: int = 20) -> List[Path]:
        """
        Génère un ou plusieurs fichiers unity
        
        Si >20 fichiers, crée plusieurs unity files pour éviter
        un fichier trop gros qui ralentirait la compilation.
        
        Args:
            source_files: Liste des .cpp à combiner
            output_dir: Où générer les unity files
            max_files_per_unity: Max de fichiers par unity
        
        Returns:
            Liste des unity files générés
        """
        
        output_dir.mkdir(parents=True, exist_ok=True)
        
        unity_files = []
        
        # Grouper les fichiers par batch
        for i in range(0, len(source_files), max_files_per_unity):
            batch = source_files[i:i + max_files_per_unity]
            
            unity_file = output_dir / f"unity_{i // max_files_per_unity}.cpp"
            
            content = self._generate_unity_content(batch, i // max_files_per_unity)
            
            unity_file.write_text(content, encoding='utf-8')
            unity_files.append(unity_file)
        
        print(f"✓ Unity build: {len(source_files)} files → {len(unity_files)} unity file(s)")
        
        return unity_files
    
    def _generate_unity_content(self, source_files: List[str], 
                               unity_index: int) -> str:
        """Génère le contenu d'un fichier unity"""
        
        content = f"""// Unity Build #{unity_index} - Auto-generated by Nken Build System
// DO NOT MODIFY MANUALLY
//
// This file combines multiple source files into one for faster compilation.
// Generated from {len(source_files)} source file(s).

"""
        
        # Include chaque fichier source
        for src in source_files:
            src_path = Path(src).absolute()
            
            # Commenter chaque include pour debug
            content += f"\n// Including: {Path(src).name}\n"
            content += f'#include "{src_path}"\n'
        
        return content
    
    def should_rebuild_unity(self, unity_file: Path, 
                            source_files: List[str]) -> bool:
        """
        Vérifie si le unity file doit être régénéré
        
        Régénérer si:
        - Unity file n'existe pas
        - Un source file est plus récent que unity
        - Nombre de fichiers a changé
        """
        
        if not unity_file.exists():
            return True
        
        unity_mtime = unity_file.stat().st_mtime
        
        # Vérifier si un source est plus récent
        for src in source_files:
            src_path = Path(src)
            if src_path.exists() and src_path.stat().st_mtime > unity_mtime:
                return True
        
        return False
    
    def estimate_speedup(self, file_count: int, 
                        avg_compile_time: float = 1.0) -> dict:
        """
        Estime le gain de vitesse avec unity build
        
        Args:
            file_count: Nombre de fichiers
            avg_compile_time: Temps moyen de compilation par fichier (secondes)
        
        Returns:
            Dict avec estimations
        """
        
        # Sans unity build
        normal_time = file_count * avg_compile_time
        
        # Avec unity build
        # Overhead: parsing tous les fichiers ensemble + quelques conflits
        unity_overhead = 1.2  # 20% overhead
        unity_time = (file_count * avg_compile_time * 0.15) * unity_overhead
        
        speedup = normal_time / unity_time
        
        return {
            'normal_time': normal_time,
            'unity_time': unity_time,
            'speedup': speedup,
            'time_saved': normal_time - unity_time
        }


class UnityBuildWarnings:
    """
    Détecte les problèmes potentiels avec Unity Build
    """
    
    @staticmethod
    def check_for_conflicts(source_files: List[str]) -> List[str]:
        """
        Détecte les problèmes potentiels:
        - Symboles static
        - Anonymous namespaces
        - #pragma once (peut causer des problèmes)
        
        Returns:
            Liste des warnings
        """
        
        warnings = []
        
        for src in source_files:
            try:
                content = Path(src).read_text(errors='ignore')
                
                # Compter les static
                static_count = content.count('static ')
                if static_count > 5:
                    warnings.append(
                        f"{Path(src).name}: {static_count} static symbols "
                        f"(may conflict in unity build)"
                    )
                
                # Anonymous namespace
                if 'namespace {' in content or 'namespace{' in content:
                    warnings.append(
                        f"{Path(src).name}: anonymous namespace "
                        f"(may conflict in unity build)"
                    )
                
            except Exception:
                continue
        
        return warnings