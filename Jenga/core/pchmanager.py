#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Nken Build System - Precompiled Headers Manager
Accélère la compilation de 2x à 10x en pré-compilant les headers communs
"""

import re
import subprocess
from pathlib import Path
from typing import Optional, List
from collections import Counter


class PrecompiledHeaderManager:
    """
    Gère la création et l'utilisation de precompiled headers (PCH)
    
    Bénéfices:
    - Réduit le temps de parsing des headers de 50-90%
    - Particulièrement efficace pour STL, Boost, Qt
    - Plus de fichiers = plus de gain
    
    Fonctionnement:
    1. Analyse les #include dans tous les fichiers source
    2. Trouve les headers utilisés dans >50% des fichiers
    3. Génère un fichier pch.h avec ces headers
    4. Compile pch.h une seule fois
    5. Réutilise le PCH pour tous les fichiers
    """
    
    def __init__(self, workspace, project, config: str, platform: str):
        self.workspace = workspace
        self.project = project
        self.config = config
        self.platform = platform
        
        self.pch_dir = Path(workspace.location) / ".cjenga" / "pch" / config
        self.pch_dir.mkdir(parents=True, exist_ok=True)
        
        self.pch_header = None
        self.pch_compiled = None
    
    def should_use_pch(self) -> bool:
        """
        Détermine si PCH est bénéfique
        
        Critères:
        - Au moins 10 fichiers source
        - Headers communs détectables
        
        PCH utile quand: nombreux fichiers + headers standards
        PCH inutile quand: peu de fichiers ou headers tous différents
        """
        
        # Compter les fichiers source
        source_count = 0
        for pattern in self.project.files:
            if '**' in pattern or '*' in pattern:
                source_count += 20  # Estimation pour wildcards
            else:
                source_count += 1
        
        # PCH bénéfique si ≥ 10 fichiers
        return source_count >= 10
    
    def find_common_includes(self) -> List[str]:
        """
        Trouve les headers utilisés dans ≥50% des fichiers
        
        Ces headers sont de bons candidats pour le PCH car:
        - Utilisés partout = gain maximal
        - Parsing répété = gaspillage éliminé
        """
        
        includes_counter = Counter()
        total_files = 0
        
        project_dir = Path(self.workspace.location)
        if self.project.location:
            project_dir = project_dir / self.project.location
        
        # Analyser tous les fichiers source
        for pattern in self.project.files:
            try:
                for src_file in project_dir.glob(pattern):
                    if src_file.suffix not in ['.cpp', '.cc', '.cxx', '.c']:
                        continue
                    
                    try:
                        content = src_file.read_text(errors='ignore')
                        
                        # Extraire tous les #include
                        includes = re.findall(r'#include\s+[<"](.+?)[>"]', content)
                        includes_counter.update(includes)
                        
                        total_files += 1
                    
                    except Exception:
                        continue
            except Exception:
                continue
        
        if total_files == 0:
            return []
        
        # Garder les includes utilisés dans ≥50% des fichiers
        threshold = max(3, total_files * 0.5)
        
        common_includes = [
            inc for inc, count in includes_counter.most_common()
            if count >= threshold
        ]
        
        # Limiter à 30 includes max (pour éviter PCH trop gros)
        return common_includes[:30]
    
    def generate_pch_header(self) -> Optional[Path]:
        """
        Génère automatiquement un fichier pch.h
        
        Contient:
        - Headers standards STL les plus courants
        - Headers du projet utilisés partout
        
        Le fichier généré est optimisé pour la compilation
        """
        
        common_includes = self.find_common_includes()
        
        if len(common_includes) < 3:
            # Pas assez de headers communs, PCH pas utile
            return None
        
        self.pch_header = self.pch_dir / "pch.h"
        
        content = """// Auto-generated Precompiled Header
// Generated by Nken Build System
// DO NOT MODIFY MANUALLY

#pragma once

"""
        
        # Headers standards STL (les plus courants)
        std_headers = [
            'iostream', 'string', 'vector', 'memory', 'algorithm',
            'map', 'unordered_map', 'set', 'unordered_set', 'array',
            'functional', 'utility', 'cstdint', 'cstring', 'cstdio',
            'fstream', 'sstream', 'list', 'deque', 'queue', 'stack'
        ]
        
        has_std = False
        for header in std_headers:
            # Inclure si trouvé dans les includes communs
            if any(header in inc for inc in common_includes):
                if not has_std:
                    content += "// Standard Library Headers\n"
                    has_std = True
                content += f"#include <{header}>\n"
        
        if has_std:
            content += "\n"
        
        # Headers du projet (avec guillemets "")
        project_headers = [inc for inc in common_includes 
                          if not any(inc.startswith(prefix) for prefix in ['<', 'std'])]
        
        if project_headers:
            content += "// Project Headers\n"
            for header in project_headers:
                # Vérifier que le header existe
                header_path = Path(self.workspace.location) / header
                if header_path.exists():
                    content += f'#include "{header}"\n'
        
        # Écrire le fichier
        self.pch_header.write_text(content)
        
        print(f"✓ PCH header generated: {len(common_includes)} includes")
        
        return self.pch_header
    
    def compile_pch(self, pch_header: Path, compiler: str, 
                   flags: List[str], includes: List[str]) -> Optional[Path]:
        """
        Compile le precompiled header
        
        Crée:
        - MSVC: fichier .pch
        - GCC/Clang: fichier .gch
        
        Ce fichier pré-compilé sera réutilisé pour tous les .cpp
        """
        
        is_msvc = "cl.exe" in compiler.lower() or "cl" == compiler.lower()
        
        if is_msvc:
            # MSVC: Créer .pch file
            pch_file = pch_header.with_suffix('.pch')
            obj_file = pch_header.with_suffix('.obj')
            
            cmd = [compiler]
            cmd.extend(flags)
            cmd.extend([f"/I{inc}" for inc in includes])
            cmd.extend([
                "/Yc",  # Create precompiled header
                f"/Fp{pch_file}",  # Output PCH file
                f"/Fo{obj_file}",  # Output object file
                "/c",
                str(pch_header)
            ])
        
        else:
            # GCC/Clang: Créer .gch file
            pch_file = pch_header.with_suffix('.h.gch')
            
            cmd = [compiler]
            cmd.extend(flags)
            cmd.extend([f"-I{inc}" for inc in includes])
            cmd.extend([
                "-x", "c++-header",  # Treat as C++ header
                "-c", str(pch_header),
                "-o", str(pch_file)
            ])
        
        try:
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=30,
                cwd=self.workspace.location
            )
            
            if result.returncode != 0:
                print(f"⚠ PCH compilation failed")
                if result.stderr:
                    # Afficher seulement les premières lignes d'erreur
                    error_lines = result.stderr.split('\n')[:10]
                    print('\n'.join(error_lines))
                return None
            
            if pch_file.exists():
                size_mb = pch_file.stat().st_size / (1024 * 1024)
                print(f"✓ PCH compiled: {pch_file.name} ({size_mb:.1f} MB)")
                self.pch_compiled = pch_file
                return pch_file
            
            return None
        
        except subprocess.TimeoutExpired:
            print(f"⚠ PCH compilation timeout (>30s)")
            return None
        except Exception as e:
            print(f"⚠ PCH compilation error: {e}")
            return None
    
    def get_pch_flags(self, pch_file: Path, compiler: str) -> List[str]:
        """
        Retourne les flags pour utiliser le PCH pendant la compilation
        
        Ces flags disent au compilateur:
        "Utilise ce header pré-compilé au lieu de le parser"
        """
        
        is_msvc = "cl.exe" in compiler.lower() or "cl" == compiler.lower()
        
        if is_msvc:
            # MSVC: /Yu pour utiliser le PCH
            return [
                "/Yu",  # Use precompiled header
                f"/Fp{pch_file}",  # PCH file path
            ]
        else:
            # GCC/Clang: -include pour inclure automatiquement
            pch_header = pch_file.with_suffix('').with_suffix('')
            return [
                "-include", str(pch_header)
            ]
    
    def is_available(self) -> bool:
        """Vérifie si le PCH a été compilé et est prêt à utiliser"""
        return self.pch_compiled is not None and self.pch_compiled.exists()